"""
This contains the flow of the chat as a script that the bot uses to remember context and prepare prompts,
its main use is to format the dialog that is to be fed into the OpenAI API.
@author Mari Shenzhen Uy, Mohawk College, Mar 2024
@author Mauricio Canul, Mohawk College, Mar 2024
@version 2.3
"""
from helper import get_json

PROMPT_FILE = "prompts.json"


def create_conversation(history: list, utterance: str, target: str = ""):
    """
    Reads a file containing prompt data, then prepares the history into proper prompt form to be appended,
    if the file is of a JSON formatted object, it will extract only the object whose key is the param target

    :return: list containing all the prompts for the OpenAI API
    """
    # We load our dialog prompts from an external file
    dialog = get_json(PROMPT_FILE)

    # If we seek a specific target and said key is on the object
    if target != "" and dict(dialog).__contains__(target):
        # Our dialog becomes the value stored within said target
        dialog = dialog.get(target)

    # For each statement found in the history list...
    for statement in history:
        # we append it to our list of prompts
        dialog.append({"role": "user", "content": statement})

    # At the end, we append out last dialog prompt, which is the user's latest utterance
    dialog.append({"role": "user", "content": utterance})

    # We send back this formatted list of prompts
    return dialog


def tune_dialog(dialog: list, json_val: dict):
    """
    Function used to do prompt engineering: it is meant to customize the "System" dialog of the
    list of prompts to be passed to the OpenAI API. It is hardcoded to work with the values to
    be generated by the 1st API call, which will discern how relevant to the bot's knowledge domain
    a question is, its tone, and the reasoning for the question.

    :param dialog: Current list of prompts, position 0 should be that of "system" and have a key named "content"
    :param json_val: The values to be used to customize the prompt
    :return: A list of prompts with the value of one of them fully formatted as required
    """
    # We extract the string to be modified
    tuning_string = dialog[0]["content"]

    # We retrieve the values to be used from a JSON file
    file = get_json(PROMPT_FILE)

    # If the file contains our "score" object...
    if file.__contains__("score"):
        # We get the score list/array
        scoreArr = file.get("score")
        # We set our score value from the json argument
        score = json_val.get("score")
        # If said value is within the range found in the score list
        if score <= len(scoreArr) and not score < 0:
            # We extract said value and concatenate it
            tuning_string += scoreArr[score]
        else:
            # If it is not, then we just extract the value at index 0
            tuning_string += scoreArr[0]

    # Then if the file contains our "tone" object...
    if file.__contains__("tone"):
        # We get said dictionary from the json file
        toneObj = dict(file.get("tone"))
        # then we get the "tone" value from the json argument
        tone = json_val.get("tone")
        # If said value is contained within the tone dictionary...
        if toneObj.__contains__(tone):
            # We concatenate it to our string
            tuning_string += toneObj.get(tone)
        else:
            # Otherwise we check if our dictionary has a default, and if so, we add said default instead
            if file.__contains__("default"):
                tuning_string += toneObj.get("default")

    # Then we finally concatenate the last lines to our tuning string
    tuning_string += "You have also figured out that " + json_val.get("explanation") \
                     + " and you may respond accordingly"

    # We set the value of the content to the formatted tuning string
    dialog[0]["content"] = tuning_string

    # We return the updated list of prompts
    return dialog
